
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  role      String   @default("user") // "user", "admin", "ca"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  campusAmbassador CampusAmbassador?
}

model CampusAmbassador {
  id           String   @id @default(uuid())
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id])
  college      String
  year         String
  phone        String
  referralCode String   @unique // Auto-generated unique code
  tokens       Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  submissions TaskSubmission[]
  referrals   Referral[]
}

model Task {
  id          String   @id @default(uuid())
  title       String
  description String
  instructions String? // Detailed instructions
  points      Int      @default(10)
  deadline    DateTime?
  type        String   @default("social") // "social", "referral", "content", "other"
  status      String   @default("active") // "active", "expired", "closed"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  submissions TaskSubmission[]
}

model TaskSubmission {
  id              String   @id @default(uuid())
  taskId          String
  task            Task     @relation(fields: [taskId], references: [id])
  caId            String
  mbassador       CampusAmbassador @relation(fields: [caId], references: [id])
  proofUrl        String   // Screenshot URL
  status          String   @default("pending") // "pending", "approved", "rejected"
  rejectionReason String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Referral {
  id              String   @id @default(uuid())
  caId            String
  mbassador       CampusAmbassador @relation(fields: [caId], references: [id])
  userEmail       String   // Email of the person referred (used on Unstop)
  proofUrl        String   // Screenshot of registration
  status          String   @default("pending") // "pending", "approved", "rejected"
  rejectionReason String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Event {
  id        String   @id @default(uuid())
  name      String
  game      String
  date      String
  status    String   @default("upcoming") // 'upcoming' | 'ongoing' | 'completed'
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  teams          Team[]
  matches        Match[]
  pointsSchemes  PointsScheme[]
}

model Team {
  id          String   @id @default(uuid())
  name        String
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id])
  totalPoints Int?     @default(0)
  totalKills  Int?     @default(0)
  wins        Int?     @default(0)
  rank        Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  participants Participant[]
  matchScores  MatchScore[]
}

model Participant {
  id        String   @id @default(uuid())
  name      String
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  role      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Match {
  id            String   @id @default(uuid())
  eventId       String
  event         Event    @relation(fields: [eventId], references: [id])
  matchNumber   Int
  team1Id       String?
  team2Id       String?
  winnerTeamId  String?
  team1Score    String?
  team2Score    String?
  status        String   @default("scheduled") // 'scheduled' | 'live' | 'completed'
  scheduledDate String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  scores        MatchScore[]
}

model MatchScore {
  id        String   @id @default(uuid())
  matchId   String
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  placement Int
  kills     Int?     @default(0)
  points    Int?     @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PointsScheme {
  id              String   @id @default(uuid())
  eventId         String
  event           Event    @relation(fields: [eventId], references: [id])
  killPoints      Int?     @default(1)
  placementPoints String?  // Changed from Json for SQLite compatibility (store as JSON string)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model RoadmapItem {
  id          String   @id @default(uuid())
  title       String
  description String?
  date        String
  status      String   @default("upcoming") // 'upcoming' | 'ongoing' | 'completed'
  eventId     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Payment {
  id             String   @id @default(uuid())
  orderId        String   @unique // Razorpay Order ID
  paymentId      String?  // Razorpay Payment ID (after success)
  amount         Float
  currency       String   @default("INR")
  status         String   @default("created") // created, paid, failed
  customerName   String
  customerEmail  String
  customerPhone  String
  quantity       Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
